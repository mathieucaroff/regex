<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, usem-scalable=no" />

  <title>Expressions régulières</title>

  <link rel="stylesheet" href="node_modules/reveal.js/dist/reset.css" />
  <link rel="stylesheet" href="node_modules/reveal.js/dist/reveal.css" />
  <link rel="stylesheet" href="node_modules/reveal.js/dist/theme/black.css" />
  <link rel="stylesheet" href="node_modules/reveal.js/plugin/highlight/monokai.css" />
  <link rel="stylesheet" href="node_modules/bootstrap/dist/css/bootstrap.min.css" />
</head>

<body>
  <script>
    class MComponent extends HTMLSpanElement {}
    customElements.define("m-", MComponent, { extends: "span" });
    class CopyComponent extends HTMLSpanElement {}
    customElements.define("copy-", CopyComponent, { extends: "span" });
  </script>

  <div class="reveal">
    <div class="slides">
      <section>
        <h1>Formation aux expressions régulières</h1>
        <em fragment>/Reg[Ee]xp?/ training course</em>
        <aside>
          Cette présentation des expressions régulières s'interessera aux
          fonctionnalités les plus utiles des regexs et à leur utilisation
          en pratique. On évitera donc les sujets les plus avancés et beaucoups
          de fonctionnalités peu utiles.
        </aside>
      </section>
      <section>
        <h2>Sommaire</h2>

        <ul class="fs-2 table-of-contents" data-unfold-content="Introduction">
          <li>
            Introduction
            <ul>
              <li>Exemple de Regex</li>
              <li>Utilisation des regexs dans l'IDE</li>
              <li>Utilisation des regexs en programmation</li>
              <li>Recherche simple</li>
            </ul>
          </li>
          <li>
            Syntaxe des regexs
            <ol style="column-count: 2;">
              <li>Groupes</li>
              <li>Alternatives</li>
              <li>Quantificateurs</li>
              <li>Classes de caractères</li>
              <li>Quantificateurs spécifiques</li>
              <li>Ancres</li>
              <li>Échapements</li>
            </ol>
          </li>
          <li>
            Remplacements et cas habituels
            <ol>
              <li>Notations</li>
              <li>Aperçu de substitution de groupe</li>
              <li>Numérotation des groupes</li>
              <li>Substitution de groupe</li>
              <li>Recherches habituelles</li>
              <li>Remplacements habituels</li>
            </ol>
          </li>
          <li>
            Les Regexs hors de l'IDE
            <ul>
              <li>en JS</li>
              <li stroke>en Python</li>
              <li>en ligne de commande</li>
            </ul>
          </li>
          <li stroke>Exercices</li>
          <li stroke>Culture, théorie et moteurs de regexs</li>
          <li>Autres ressources</li>
        </ul>
      </section>

      <section>
        <h1>Introduction</h1>
      </section>
      <section >
        <h2>Les expressions régulières c'est quoi ?</h2>
        <h2 fragment>À quoi ça sert?</h2>
        <div fragment class="decoration-right-rotated">
          <code><pre>grep -E 'useState\((true|false)\)' -R src | sort | uniq -c</pre></code>
        </div>
        <div fragment class="decoration-left-rotated">
          <code>s/(myAuthSecrets?)(-+[Pp]ages?)?/$1/g</code>
        </div>
        <img fragment src="img/ant-renamer-regex-substitution.png" />
        <aside>
          Les regexs sont un outil de recherche et de remplacement de motifs
          de caractères dans des données textuelles. Ces motifs sont décrits
          par un langage spécifique à un domain, ou DSL, Domain Specifique
          Language : le DSL des expressions régulières. || Les regexs peuvent
          servir à toutes sorte de choses. Par exemple: || Trouver des données
          spécifiques dans les logs. || Faire des statistiques. || Chercheo des
          fichiers par leur nom. || Renommer plusieurs variables simultanement.
          || Rennomer des fichiers. || Valider des que données textuelles
          entrées par un utilisateur sont bien conformes à un format spécifique.
        </aside>
      </section>
      <section>
        <h2>Exemple de regex</h2>
        <a href="https://regex101.com/?regex=^ *(\+33|0)( ?[0-9]){7} *$"><code>/^ *(\+33|0)( ?[0-9]){7} *$/</code></a>
        <aside>
          Voici une expression régulière qui match uniquement les numéros de téléphone.
          Notez que dans cette présentation, toutes les expressions régulières sont délimitées par le caractère slash. Cette notation provient des langages de scriptage qui ont popularisé les expressions régulières.
        </aside>
      </section>
      <section>
        <section>
          <h2>Utiliser les regexs dans l'IDE</h2>
          <div class="r-stack fs-2">
            <div class="fade-out" data-fragment-index="1">
              <div>
                <img src="./img/vscode-regex-search.png" alt="Using regex search in VSCode" />
              </div>
              <em>Regex dans VSCode</em> - <code>Alt+R</code>
            </div>
            <div class="fade-in" data-fragment-index="1">
              <div>
                <a href="https://stackoverflow.com/q/3760444"><img src="./img/vim-regex-search.png"
                    alt="Using regex search in Vim" height="200" /></a>
              </div>
              <em>Regex dans Vim</em> - <code>/\v</code> (<code>:nnoremap / /\v</code>)
            </div>
          </div>
          <aside>
            Pour utiliser les expressions régulière dans votre IDE favori, il
            y a le raccourci clavier Alt+R pour VSCode. Pour Vim, il faut
            activer le mode very magic avec `\v` pour avoir des Regex
            traditionelles. Pour les autres éditeurs de text et IDE, c'est
            souvent une checkbox à cocher.
          </aside>
        </section>
      </section>
      <section utilisation-en-programmation>
        <h2>Utilisation des regexs en programmation</h2>
        <table style="font-size: 80%;">
          <thead>
            <tr>
              <th>Action</th>
              <th>Sortie</th>
              <th>Exemple en JS</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>Test</td>
              <td>booléen</td>
              <td><code>c = /a(bc)/.test("abc")</code></td>
            </tr>
            <tr>
              <td>Recherche</td>
              <td>entier</td>
              <td><code>k = "abc".search(/a(bc)/)</code></td>
            </tr>
            <tr>
              <td>Match simple</td>
              <td>string[]</td>
              <td><code>m = "abc".match(/a(bc)/)</code></td>
            </tr>
            <tr>
              <td>Match global</td>
              <td>string[]</td>
              <td><code>m = "abc".match(/a(bc)/g)</code></td>
            </tr>
            <tr>
              <td>Remplacement*</td>
              <td>string</td>
              <td><code>m = "abc".replace(/a(bc)/g, "")</code></td>
            </tr>
            <tr>
              <td>Séparation</td>
              <td>string[]</td>
              <td><code>m = "abc".split(/a(bc)/g)</code></td>
            </tr>
          </tbody>
        </table>
        <div style="text-align: left; margin-top: 20px;">
          <ul no-list-style style="font-size: 70%;">
            <li fragment>Remplacement* → simple ou global</li>
            <li fragment>Remplacement* → motif ou callback</li>
          </ul>
        </div>
      </section>
      <section>
        <section>
          <h2 simplesearch>Recherche simple</h2>
          <em>Matcher du text, caractère pour caractère</em>

          <ul class="fs-1">
            <li>Les lettres (<code>A-Za-z</code>)</li>
            <li>Les nombres (<code>0-9</code>)</li>
            <li>Les blancs<ul>
                <li>Espaces</li>
                <li>Tabulations</li>
                <li>Retours à la ligne</li>
              </ul>
            </li>
            <li>
              La majorité des ponctuations (17 / 31)
            </li>
          </ul>
        </section>
        <section>
          <h2><copy- from="[simplesearch]" /></h2>
          <h4>Exemples</h4>
          <ul class="fs-1">
            <li fragment>"Foo" <code fragment>/Foo/</code></li>
            <li fragment>"H3110" <code fragment>/H3110/</code></li>
            <li fragment>"a, b" <code fragment>/a, b/</code></li>
          </ul>
        </section>
      </section>

      <section>
        <h1 syntaxe>Syntaxe des regexs</h1>
      </section>
      <section>
        <h2><copy- from="[syntaxe]" /></h2>
        <ul class="fs-2 table-of-contents" data-unfold-content="Syntaxe des regexs"></ul>
      </section>
      <section>
        <h2>Groupes</h2>
        <code>(...)</code>
        <h4 padding fragment>Exemples</h4>
        <ul>
          <li fragment><code>/(Foo)/</code><span fragment> → "Foo"</span></li>
          <li fragment><code>/(F)(o)(o)/</code><span fragment> → "Foo"</span></li>
          <li fragment><code>/((((Foo))))/</code><span fragment> → "Foo"</span></li>
          <li fragment><code>/((((F))((o)o)))/</code><span fragment> → "Foo"</span></li>
          <li fragment><code>/((((Foo))/</code><span fragment>❌</span></li>
          <li fragment><code>/)Foo(/</code><span fragment>❌</span></li>
          <li fragment><code>/((Foo))))/</code><span fragment>❌</span></li>
        </ul>
        <aside>
          Placer un morceau d'expression régulière entre deux parenthèses crée un groupe.
          Pour qu'une expression régulière soit valide, chaque parenthèses ouvrante
          doit être associé à une parenthèses fermante et vice-versa.
        </aside>
      </section>
      <section>
        <h2>Alternatives</h2>
        <code>a|b</code>
        <h4 fragment>Exemples</h4>
        <ul>
          <li fragment><code>/Tooltip|Popover/</code></li>
          <li fragment><code>/un pain au chocolat|une chocolatine/</code></li>
          <li fragment>
            <code>/(Date|Time|DateTime)Picker/</code>
            <ul>
              <li fragment><code>/DatePicker|TimePicker|DateTimePicker/</code></li>
            </ul>
          </li>
          <li fragment>
            <code>/(jp(e|)|pn)g|bmp|gif/</code>
            <ul>
              <li fragment><code>/jpeg|jpg|png|bmp|gif/</code></li>
            </ul>
          </li>
          <li fragment>
            <code>/(|_)(a|b)(x|y|z)/</code>
            <ul>
              <li fragment><code>/ax|ay|az|bx|by|bz|_ax|_ay|_az|_bx|_by|_bz/</code></li>
            </ul>
          </li>
        </ul>
        <aside>
          Le symbole "bar verticale" `|` permet de définir plusieurs alternatives
          que le moteur d'expression régulière essaira de matcher dans l'ordre.
          Il est possible limiter différentes alternatives en les placer entre
          parenthèses.
        </aside>
      </section>
      <section>
        <section>
          <h2>Quantificateurs</h2>
          <em>Répétitions de motifs</em>
          <table>
            <thead>
              <tr>
                <th>Syntaxe</th>
                <th>Exemples</th>
              </tr>
            </thead>
            <tbody>
              <tr fragment>
                <td><code>/ab*/</code></td>
                <td>a, ab, abb, abbb...</td>
              </tr>
              <tr fragment>
                <td><code>/ab+/</code></td>
                <td><span style="margin: 0 1em" />ab, abb, abbb...</td>
              </tr>
              <tr fragment>
                <td><code>/ab?/</code></td>
                <td>a, ab</td>
              </tr>
            </tbody>
          </table>
          <aside>
            Il est possible de spécifier qu'un caractère peut être répété plusieurs fois.
            Le caractère "étoile" `*` indique que le caractère le précède peut apparaitre entre 0 et une infinité de
            fois.
            Le caractère "plus" `+` indique que le caractère qui le précède peut être répété infiniment.
            Enfin, le caractère "point d'interrogation" `?` indique que le caractère qui le précède est optionnel ;
            il peut être présent ou absent.
          </aside>
        </section>
        <section>
          <h2>Quantificateurs</h2>
          <h4>Exemples d'applications</h4>
          <ul>
            <li fragment>
              "http:" et "https:"
              <code fragment>/https?:/</code>
            </li>
            <li fragment>
              "être content" et "être très content" et "être très très content"
              <ul fragment>
                <li><code>/être (très )*content/</code></li>
                <li fragment><code>/être( très)* content/</code></li>
              </ul>
            </li>
            <li fragment>
              <code fragment>/(bonjour_|salut_)*/</code>
              <ul fragment>
                <li></li>
                <li fragment><code>/être( très)* content/</code></li>
              </ul>
            </li>
          </ul>
          <aside>
            Je voudrais attirer votre attention sur le cas d'une expression régulière complexe placée à l'interieur d'un groupe qui peut être répété.
            Lorsque cela se produit, le moteur d'expression régulières se réfèrera toujours à l'expression régulière source pour matcher les occurences successives du groupe.
            Ainsi, le motif présenté est bien matché en entier par l'expression régulière.
          </aside>
        </section>
        <section>
          <h2>Quantificateurs</h2>
          <h4>Répétition de groupes complexes</h4>
        </section>
      </section>
      <section>
        <h2 classes>Classes de caractères</h2>
        <ol fragment>
          <li>Le point: <code>.</code></li>
          <li>Les énumérations complètes: <code>[abcdef]</code></li>
          <li>Les plages: <code>[a-f]</code></li>
          <li>Les classes négatives: <code>[^g-z]</code></li>
        </ol>
      </section>
      <section>
        <h2><copy- from="[classes]" /></h2>
        <h4>Matcher n'import quel caractère: le point</h4>
        <code>/./</code>
        <p fragment><code>/.*/</code></p>
        <p fragment><code>/(.|\n)*/</code></p>
      </section>
      <section>
        <h2><copy- from="[classes]" /></h2>
        <h4>Matcher un caractère au choix :<br>les énumérations complètes</h4>
        <code>/[abcdef]/</code>
        <div fragment><code>/(a|b|c|d|e|f)/</code></div>
        <h4 fragment>Exemples</h4>
        <ul>
          <li fragment>
            grand-mère et grand-père
            <code fragment>/grand-[mp]ère/</code>
          </li>
          <li fragment>
            boucher, coucher, doucher, loucher, moucher, toucher
            <code fragment>/[bcdlmt]oucher/</code>
          </li>
        </ul>
      </section>
      <section>
        <h2><copy- from="[classes]" /></h2>
        <h4>Plages de caractères</h4>
        <p><em fragment>(Plages ASCII)</em></p>
        <ul>
          <li fragment>
            les majuscules
            <code fragment>/[A-Z]/</code>
          </li>
          <li fragment>
            les lettres minuscules
            <code fragment>/[a-z]/</code>
          </li>
          <li fragment>
            les chiffres
            <code fragment>/[0-9]/</code>
          </li>
          <li fragment>
            les lettres
            <code fragment>/[A-Za-z]/</code>
          </li>
          <li fragment>
            les chiffres hexadécimaux
            <code fragment>/0x[0-9A-Fa-f]+/</code>
          </li>
          <li fragment>
            les identifieurs
            <code fragment>/[A-Za-z_][A-Za-z_0-9]*/</code>
          </li>
        </ul>
      </section>
      <section>
        <h2><copy- from="[classes]" /></h2>
        <h4>Les classes négatives</h4>
        <p><em fragment>(Les compléments de classe de caractères)</em></p>
        <div><code fragment>/[^x]/</code></div>
        <ul>
          <li fragment><code>/[^"]/</code><span fragment> → <code>/"[^"]*"/</code></span></li>
          <li fragment><code>/[^"0-9]/</code><span fragment> → <code>/"[^"0-9]*"/</code></span></li>
        </ul>
      </section>
      <section>
        <h2 qs>Quantificateurs spécifiques</h2>
        <em>Répétitions de motifs</em>
        <table>
          <thead>
            <tr>
              <th>Syntaxe</th>
              <th>Exemples</th>
            </tr>
          </thead>
          <tbody>
            <tr fragment>
              <td><code>/ab{4}/</code></td>
              <td fragment>abbbb</td>
            </tr>
            <tr fragment>
              <td><code>/ab{2,4}/</code></td>
              <td fragment>abb, abbb, abbbb</td>
            </tr>
            <tr fragment>
              <td><code>/ab{2,}/</code></td>
              <td fragment>abb, abbb, abbbb, abbbbb...</td>
            </tr>
          </tbody>
        </table>
      </section>
      <section>
        <h2><copy- from="[qs]" /></h2>
        <em>Répétitions de motifs</em>
        <table>
          <thead>
            <tr>
              <th>Syntaxe</th>
              <th>Description</th>
              <th>Équivalent</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td data-fragment-index="1"><code>/x*/</code></td>
              <td data-fragment-index="2" class="fs-2">"Autant de fois que possible"</td>
              <td fragment><code>/x{0,}/</code></td>
            </tr>
            <tr>
              <td data-fragment-index="1"><code>/x+/</code></td>
              <td data-fragment-index="2" class="fs-2">"Au moins une fois"</td>
              <td fragment><code>/x{1,}/</code></td>
            </tr>
            <tr>
              <td data-fragment-index="1"><code>/x?/</code></td>
              <td data-fragment-index="2" class="fs-2">"Zero ou une fois"</td>
              <td fragment><code>/x{0,1}/</code></td>
            </tr>
          </tbody>
        </table>
      </section>
      <section>
        <h2>Ancres</h2>
        <em>Assertions de longeur nulle</em>
        <table>
          <tbody>
            <tr>
              <td>
                <ol>
                  <li data-fragment-index="1">Le carret: <code>/^/</code></li>
                  <li data-fragment-index="2">Le dollard: <code>/$/</code></li>
                </ol>
              </td>
              <td>
                <ul no-list-style>
                  <li data-fragment-index="3"> → Début de ligne</li>
                  <li data-fragment-index="4"> → Fin de ligne</li>
                </ul>
              </td>
            </tr>
          </tbody>
        </table>
      </section>
      <section>
        <h2>Échapements</h2>
        <em data-fragment-index="0"><code>/\x/</code></em>
        <table>
          <tbody>
            <tr class="fs-2">
              <td>
                <ol>
                  <li data-fragment-index="1">Assertion de longeur nulle</li>
                  <li data-fragment-index="2">Caractères particuliers</li>
                  <li data-fragment-index="3">Classes de caractères Perl</li>
                  <li data-fragment-index="4">Ponctuations</li>
                  <li data-fragment-index="5">Contexte des classes de caractères</li>
                </ol>
              </td>
              <td>
                <ul no-list-style>
                  <li data-fragment-index="6">→ <code>\b, \B, ...</code></li>
                  <li data-fragment-index="7">→ <code>\n, \t, \r, ...</code></li>
                  <li data-fragment-index="8">→ <code>\d, \w, \s, ...</code></li>
                  <li data-fragment-index="9">→ <code>\+, \$, \\, ...</code></li>
                  <li data-fragment-index="10">→ <code>[\x], [^\x]</code></li>
                </ul>
              </td>
            </tr>
          </tbody>
        </table>
      </section>
      <section>
        <h2>Échapements</h2>
        <h4>Assertion de longeur nulle</h4>
        <ul>
          <li fragment>
            L'anti-slash "b": <code>/\b/</code>
            <ul><li fragment>Début ou fin d'un mot ASCII</li></ul>
          </li>
        </ul>
      </section>
      <section>
        <h2>Échapements</h2>
        <h4>Caractères particuliers</h4>
        <table>
          <thead>
            <tr>
              <th>Syntaxe</th>
              <th>Description</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><code>/\n/</code></td>
              <td class="fs-2">Retour à la ligne (LF: Line Feed)</td>
            </tr>
            <tr>
              <td><code>/\t/</code></td>
              <td class="fs-2">Tabulation</td>
            </tr>
            <tr>
              <td><code>/\r/</code></td>
              <td class="fs-2">Retour chariot (CR: Carriage Return)</td>
            </tr>
            <tr>
              <td><code>/\r\n/</code></td>
              <td class="fs-2">"CRLF": Carriage Return Line Feed</td>
            </tr>
          </tbody>
        </table>
      </section>
      <section>
        <h2>Échapements</h2>
        <h4>Classe de caractères Perl</h4>
        <table>
          <thead>
            <tr>
              <th>Syntaxe</th>
              <th>Description</th>
              <th>Équivalent</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td data-fragment-index="1"><code>/\d/</code></td>
              <td fragment class="fs-2">"Chiffre"</td>
              <td fragment><code>/[0-9]/</code></td>
            </tr>
            <tr>
              <td data-fragment-index="1"><code>/\w/</code></td>
              <td fragment class="fs-2">"Caractère de mot"</td>
              <td fragment><code>/[0-9A-Za-z_]/</code></td>
            </tr>
            <tr>
              <td data-fragment-index="1"><code>/\s/</code></td>
              <td fragment class="fs-2">"Caractère d'espacement"</td>
              <td fragment><code>/[\t\n\f\r ]/</code></td>
            </tr>
            <tr>
              <td data-fragment-index="1"><code>/\S/</code></td>
              <td fragment class="fs-2">"Non-caractère d'espacement"</td>
              <td fragment><code>/[^\t\n\f\r ]/</code></td>
            </tr>
          </tbody>
        </table>
      </section>
      <section>
        <h2>Échapements</h2>
        <h4>Ponctuations (31)</h4>
        <em>Dans le context générale</em>
        <ul>
          <li fragment>
            Ponctuations neutres (17):
            <ul>
              <li><code>`~!@#%&-=_;:'",&lt;></code></li>
            </ul>
          </li>
          <li fragment>
            Ponctuations à échapper (14):
            <ul>
              <li><code>$^*()+[]{}.?/\</code></li>
              <li fragment><code>\$\^\*\(\)\+\[\]\{\}\.\?\/\\</code></li>
            </ul>
          </li>
        </ul>
      </section>
      <section>
        <h2>Échapements</h2>
        <h4>Ponctuations</h4>
        <em>Dans le context d'une classe de caractères <code>[x]</code></em>
        <ul>
          <li fragment>
            Ponctuations à échapper: <span fragment><code>[]^-/\</code></span>
        </ul>
      </section>

      <section>
        <aside>
          Félicitation! Vous avez désormais les connaissances suffisantes pour
          lire et écrire des expressions régulières. En bonus, voici une feuille
          de triche qui reprends les syntaxes présentées.
        </aside>
      </section>

      <section
        data-background-iframe="re2.syntax.short.cheatsheet.styled.html"
      ></section>

      <section>
        <h2 replacements>Remplacements et cas habituels</h2>
        <h4>Notations</h4>
        <ul>
          <li fragment><code>x</code>, <code>y</code>, <code>z</code><span fragment> → regex ou morceau de regex</span></li>
          <li fragment><code>a</code>, <code>b</code>, ...<span fragment> → caractère</span></li>
          <li fragment>Remplacements <em>(notations de Perl):</em>
            <ul>
              <li fragment><code>s/&lt;regex&gt;/&lt;remplacement&gt;/&lt;flags&gt;</code></li>
              <li fragment><code>s/abc/def/g</code></li>
            </ul>
          </li>
        </ul>
        <aside>
          Pour la suite de cette présentation, nous utiliserons les notations indiquées dans cette slide:
          Les lettres x, y et z désigne des expressions régulières à-part-entières qui peuvent être inclueses au sein d'un plus grande expression régulière.
          Les lettres a, b, c etc. désigne un caractère seul.
          Pour les remplacements, nous utiliserons la notation que voici. Il s'agit de la notation avec des slashes de Perl. Cette notation est utilisée notemment en Perl et en Sed. Par exemple, le remplacement suivant remplace toutes les suites de lettre "abc" en "def".
        </aside>
      </section>

      <section>
        <h2><copy- from="[replacements]" /></h2>
        <h4>Aperçu de substitution de groupe</h4>
        <div class="r-stack">
          <pre fragment><code class="text">s/^deb (.*)$/</code></pre>
          <pre fragment><code class="text">s/^deb (.*)$/deb $1\ndeb-src $1/g</code></pre>
        </div>
        <aside>
          Nous avons vu précédement qu'un groupe est un morceau d'expression régulière placé entre parenthèses. Nous avons aussi vu que les groupes permettent de restreindre la portée des alternatives, et d'étendre celle des quantificateurs. (Eh bien) les groupes ont aussi un rôle dans les remplacements par expression régulières :
          Un système de numérotation des groupes permet de réutiliser la valeur prise par un groupe dans le texte de remplacement. Voici un remplacement dans lequel le contenu d'origine est partiellement dupliqué grâce à une référence au groupe numéro 1.

          Cette regex est provient du Bastion et est appliquée au fichier /etc/apt/sources.list. Elle sert à ajouter une entrée debian-source pour chaque entrée de package debian déjà présente dans le fichier.
        </aside>
      </section>

      <section>
        <section>
          <h2><copy- from="[replacements]" /></h2>
          <h4>Numérotation des groupes</h4>
          <pre fragment>
            <code class="text">
            /(x)(y)(z)/
            ^^  ^  ^
            01  2  3
            </code>
          </pre>
          <pre fragment class="text">
            <code>
            /((x)(y))(z)/
            ^^^  ^   ^
            012  3   4
            </code>
          </pre>
          <aside>
            Pour pouvoir désigner n'importe quel groupe d'une expression régulière, un système de numérotation a été mis en place. Le numéro 0 désigne la totatlité du text matché par l'expression régulière. Les numéros suivants désigne les groupes, par ordre d'apparition de leur paranthèse ouvrante.
          </aside>
        </section>
        <section>
          <h2><copy- from="[replacements]" /></h2>
          <h4>Numérotation des groupes</h4>
          <h5>Groupes non-capturant</h5>
          <pre fragment>
            <code class="text">
            /(?:x)(y)(?:z)/;
            ^     ^
            0     1
            </code>
          </pre>
          <div class="r-stack">
            <pre fragment class="text">
              <code>
              /((?:x)(?:(y)))(z)/


              </code>
            </pre>
            <pre fragment class="text">
              <code>
              /((?:x)(?:(y)))(z)/
              ^^        ^    ^
              01:xy     2:y  3:z
              </code>
            </pre>
          </div>
          <aside>
            Il existe une syntax appelée groupe non-capturant. Cette syntax est assez peu utile. Elle permet d'avoir des groupes utilisable pour les alternatives et les quantificateurs, mais qui ne contribuent pas à la numérotation et qui ne sont donc pas accessibles dans le remplacement. Par exemple, dans la regex suivante, il n'y qu'un seul groupe, celui qui match juste "y".

            Dans l'expression régulière que voici, quels sont les groupes numérotés ? combien y en a t'il ? et quels sont leur numéros respectifs ?
          </aside>
        </section>
      </section>
      <section automaticGroupSubstitutionSyntax>
        <section>
          <h2>Remplacements et cas habituels</h2>
          <h4>Substitution de groupe: groupes inutilisés</h4>
          <p><code fragment>s/((a)|b)c/0:$0. 1:$1. 2:$2. 3:$3./g</code></p>
          <p><code fragment>"HI ac AND bc BYE"</code></p>
          <p style='font-size: 90%;'><code fragment>"HI 0:ac. 1:a. 2:a. 3:. AND 0:bc. 1:b. 2:. 3:. BYE"</code></p>
        </section>
        <section>
          <h2>Remplacements et cas habituels</h2>
          <h4>Substitution de groupe: groupes réutilisés</h4>
          <p><code fragment>s/[0-9](-([0-9]))*/0:$0. 1:$1. 2:$2./g</code></p>
          <p><code fragment>"SUM: 5 END"</code></p>
          <p><code fragment>"SUM: 0:5. 1:. 2:. END"</code></p>
          <p><code fragment>"SUM: 9-8-7-6 END"</code></p>
          <p><code fragment>"SUM: 0:9-8-7-6. 1:-6. 2:6. END"</code></p>
        </section>
      </section>
      <section>
        <section>
          <h2>Remplacements et cas habituels</h2>
          <h4>Recherches habituelles</h4>
          <ul>
            <li fragment><code>/\bword\b/</code></li>
            <li fragment><code>/\n\n/</code> ou <code>/^$/</code></li>
            <li fragment><code>/\n\n\n/</code> ou <code>/\n\n\n+/</code></li>
            <li fragment><code>/^debut-de-ligne/</code></li>
            <li fragment><code>/fin-de-ligne$/</code></li>
          </ul>
        </section>
        <section>
          <h2>Remplacements et cas habituels</h2>
          <h4>Recherches habituelles</h4>
          <ul>
            <li fragment>
              <code>x(sx)*</code> ou <code>(xs)*x</code>
              <ul no-list-style>
                <li fragment><code>(\w+m)*\w+</code> ou <code>\w+(,\w+)*</code></li>
                <li fragment>lion,tiger,gnu,penguin</li>
              </ul>
            </li>
            <li fragment>Trouver deux caractères distants:
              <ul>
                <li fragment><code>/a[^b]*b/</code> ou <code>/a.*b/</code></li>
              </ul>
            </li>
            <li fragment>Trouver une chaine de caractères simple:
              <ul>
                <li fragment><code>/"[^"]*"/</code></li>
              </ul>
            </li>
          </ul>
        </section>
      </section>
      <section automaticGroupSubstitutionSyntax>
        <h2>Remplacements et cas habituels</h2>
        <h4>Remplacements habituels</h4>
        <ul style="column-count: 2;">
          <li fragment>Supprimer un motif:
            <ul>
              <li fragment><code>s/x//g</code></li>
              <li fragment><code>s/(x)y(z)/$1$2/g</code></li>
              <li fragment><code>s/.*(x)/$1/g</code></li>
              <li fragment><code>s/(x).*/$1/g</code></li>
            </ul>
          </li>
          <li fragment>Supprimer les lignes vides multiples:
            <ul>
              <li fragment><code>s/\n\n\n+/\n\n/g</code></li>
            </ul>
          </li>
          <li fragment>Doubler un motif:
            <ul>
              <li fragment><code>s/a(x)b/a$1$1b/g</code></li>
            </ul>
          </li>
        </ul>
      </section>
      <section innerHTML="$1 vs \1">
        <h2>Remplacements</h2>
        <h4><code>$1</code> vs <code>\1</code></h4>

        <ul>
          <li fragment>VSCode<span fragment> → <code>$1</code></span></li>
          <li fragment>Sed<span fragment> → <code>\1</code></span></li>
          <li fragment>
            Languages
            <table>
              <tr>
                <td>
                  <ul>
                    <li fragment>Python<span fragment> → <code>\1</code></span></li>
                    <li fragment>Ruby<span fragment> → <code>\1</code></span></li>
                    <li fragment>JS<span fragment> → <code>$1</code></span></li>
                    <li fragment>Perl<span fragment> → <code>$1</code> ou <code>\1</code> <small>(préférer <code>$1</code></span>)</small></li>
                    <li fragment>PHP<span fragment> → <code>$1</code> ou <code>\1</code> <small>(préférer <code>$1</code></span>)</small></li>
                  </ul>
                </td>
                <td>
                  <ul>
                    <li fragment>Java<span fragment> → <code>$1</code></span></li>
                    <li fragment>C#<span fragment> → <code>$1</code></span></li>
                    <li fragment>Golang<span fragment> → <code>$1</code></span></li>
                    <li fragment>Rust<span fragment> → <code>$1</code></span></li>
                  </ul>
                </td>
              </tr>
            </table>
          </li>
        </ul>
        <aside>
          Delphi, R, and Tcl use the `\n` syntax for regex replacement. (source: www.regular-expressions.info)
        </aside>
      </section>

      <section>
        <h1 horsIDE>Les Regex hors de l'IDE</h1>
      </section>
      <section>
        <h2><copy- from="[horsIDE]" /></h2>
        <ul class="fs-2 table-of-contents" data-unfold-content="Les Regexs hors de l'IDE"></ul>
      </section>

      <section>
        <copy- from="[utilisation-en-programmation]" />
      </section>

      <section>
        <h1 commandLine>Les Regexs en ligne de commande</h1>
      </section>
      <section>
        <h2><copy- from="[commandLine]" /></h2>
        <h4>L'outil grep</h4>
        <ul>
          <li fragment><code>grep -E '&lt;regex>'</code> (<code>grep -r</code>)</li>
          <li fragment><code>grep -Eo</code><span fragment> → --<code>o</code>nly-matching"</span></li>
          <li fragment><code>grep -Ev</code><span fragment> → --in<code>v</code>ert-match"</span></li>
          <li fragment><code>grep -Ei</code><span fragment> → --<code>i</code>gnore-case"</span></li>
        </ul>
      </section>
      <section>
        <h2><copy- from="[commandLine]" /></h2>
        <h4>L'outil grep</h4>
        <ul>
          <li fragment>search for a file by regex
            <ul><li fragment><code>grep -lR . | grep -E '&lt;filepath-regex>'</code></li></ul>
          </li>
        </ul>
      </section>
      <section>
        <h2><copy- from="[commandLine]" /></h2>
        <h4>L'outil sed</h4>
      </section>
      <section>
        <h2><copy- from="[commandLine]" /></h2>
        <h4>L'outil sed</h4>
      </section>
      <section>
        <h2><copy- from="[commandLine]" /></h2>
        <em>(Récapitulatif)</em>
        <table style="font-size: 60%;" fragment>
          <thead>
            <tr>
              <th>Action</th>
              <th>Sortie</th>
              <th>Exemple en Bash</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>Test</td>
              <td style="font-size: 75%;">code de sortie</td>
              <td><code>grep -E 'x' >/dev/null && ...</code></td>
            </tr>
            <tr>
              <td>Recherche</td>
              <td style="font-size: 75%;">numéro de ligne</td>
              <td><code>grep -En 'x'</code> ou <code style="margin-left: 4px;">nl | grep 'x'</code></td>
            </tr>
            <tr>
              <td>Remplacement<br>ligne par ligne</td>
              <td>text</td>
              <td><code>sed 's/regex(p?)/RegEx\1/g'</code></td>
            </tr>
            <tr>
              <td>Remplacement<br>multiligne</td>
              <td>text</td>
              <td><code>tr '\n' ~ | sed 's/~~~+/~~/g | tr '~' \n'</code></td>
            </tr>
          </tbody>
        </table>
        <div fragment style="text-align: left; margin-top: 20px;">
          <ul no-list-style style="font-size: 70%;">
            <li>Match* → [entier, entier, string][]</li>
            <li>Remplacement** → simple ou global</li>
          </ul>
        </div>
      </section>

      <section>
        <h1 exercices>Exercices</h1>
      </section>

      <section>
        <h1 culture>Culture, théorie et moteurs de regexs</h1>
      </section>

      <section>
        <h2><copy- from="[culture]" /></h2>
        <ul class="fs-2 table-of-contents" data-unfold-content="Culture, théorie et moteurs de regexs"></ul>
      </section>

      <section>
        <h1>Autres ressources</h1>
      </section>
      <section>
        <ul>
          <li><a href="https://regex101.com">Regex 101</a></li>
          <li><a href="https://www.regular-expressions.info">regular-expression.info</a></li>
          <li><a href="https://regexr.com/">RegexR (open-source!)</a></li>
          <li><a href="https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_regular_expressions">Guide des Regex Powershell</li>
          <li><a href="https://docs.python.org/3/library/re.html">Documentation Python du module <code>re</code></a></li>
          <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_expressions">Guide Regex de MDN</a></li>
          <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_expressions/Cheatsheet">Cheatsheet Regex de MDN</a></li>
        </ul>
      </section>
    </div>
  </div>

  <style>
    ul[no-list-style] {
      list-style: none;
    }

    [padding] {
      padding-top: 50px;
    }

    [innerHTML] {
      color: #808080;
      font-size: 20px;
    }

    [stroke] {
      text-decoration: line-through;
    }

    img[alt="regex-example"] {
      -webkit-filter: invert(1);
      filter: invert(1);
    }

    .red m-,
    div m-.red {
      color: red;
    }

    .green m-,
    div m-.green {
      color: green;
    }

    .blue m-,
    div m-.blue {
      color: #0066ff;
    }

    .decoration-left-rotated {
      transform: translate(-300px, 0) rotate(35deg);
    }

    .decoration-right-rotated {
      transform: translate(300px, 0) rotate(-25deg);
    }
  </style>

  <script>
    if (!location.search.includes("print-pdf")) {
      document.querySelectorAll("[fragment], [data-fragment-index]").forEach((element) => {
        element.classList.add("fragment")
      })
    }
    document.querySelectorAll("aside").forEach((element) => {
      element.classList.add("notes")
    })
    document.querySelectorAll("[innerHTML]").forEach((element) => {
      element.innerHTML = element.getAttribute("innerHTML")
    })

    let sValue = new URLSearchParams(location.search).get("s")
    if (sValue === 'shell') {
      document.querySelectorAll("[automaticGroupSubstitutionSyntax]").forEach((s) => {
        s.innerHTML = s.innerHTML.replace(/\$(\d)/g, `\\$1`)
      });
    }
    document.querySelectorAll("copy-").forEach((copy) => {
      copy.innerHTML = document.querySelector(
        copy.getAttribute("from")
      ).innerHTML;
    });
  </script>
  <script src="node_modules/reveal.js-menu/menu.js"></script>
  <script src="revealTOC.ts" type="module"></script>
  <script src="reveal.ts" type="module"></script>
  <script>
  </script>
</body>

</html>